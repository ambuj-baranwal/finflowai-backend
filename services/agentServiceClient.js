class AgentServiceClient {
  constructor() {
    this.baseURL = process.env.PYTHON_SERVICE_URL || 'http://localhost:8000';
    this.timeout = 30000; // 30 seconds
  }

  async makeRequest(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    const defaultOptions = {
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    };

    try {
      // In a real implementation, you'd use fetch or axios
      // For now, return mock responses
      console.log(`[Mock] Would make request to: ${url}`);
      console.log(`[Mock] Options:`, { ...defaultOptions, ...options });
      
      return this.getMockResponse(endpoint, options);
    } catch (error) {
      console.error(`Error calling Python service at ${url}:`, error);
      throw new Error(`Python service unavailable: ${error.message}`);
    }
  }

  getMockResponse(endpoint, options) {
    // Mock responses for different endpoints
    if (endpoint.includes('/chat/completion')) {
      return {
        success: true,
        data: {
          response: "This is a mock response from the AI agent. In production, this would be generated by the Python service.",
          model: "mock-model",
          usage: {
            prompt_tokens: 50,
            completion_tokens: 25,
            total_tokens: 75
          }
        }
      };
    }

    if (endpoint.includes('/documents/process')) {
      return {
        success: true,
        data: {
          status: "processed",
          chunks: 5,
          embeddings_created: 5,
          processing_time: 2.5
        }
      };
    }

    if (endpoint.includes('/embeddings/search')) {
      return {
        success: true,
        data: {
          matches: [
            {
              chunk_text: "Mock relevant content chunk 1",
              score: 0.92,
              metadata: { page: 1, section: "Introduction" }
            },
            {
              chunk_text: "Mock relevant content chunk 2", 
              score: 0.87,
              metadata: { page: 3, section: "Methods" }
            }
          ]
        }
      };
    }

    return {
      success: true,
      data: { message: "Mock response" }
    };
  }

  async generateChatCompletion(messages, options = {}) {
    const payload = {
      messages,
      model: options.model || 'gpt-3.5-turbo',
      temperature: options.temperature || 0.7,
      max_tokens: options.max_tokens || 1000
    };

    return this.makeRequest('/api/chat/completion', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  async processDocument(documentData) {
    const payload = {
      document_id: documentData.id,
      title: documentData.title,
      file_type: documentData.fileType,
      cloud_url: documentData.cloudReferenceUrl,
      metadata: documentData.parserMetadata
    };

    return this.makeRequest('/api/documents/process', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  async searchEmbeddings(query, documentIds = [], limit = 5) {
    const payload = {
      query,
      document_ids: documentIds,
      limit
    };

    return this.makeRequest('/api/embeddings/search', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  async generateMindMap(documentId, options = {}) {
    const payload = {
      document_id: documentId,
      max_nodes: options.maxNodes || 20,
      depth: options.depth || 3
    };

    return this.makeRequest('/api/mindmap/generate', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  async generateFlowchart(documentId, options = {}) {
    const payload = {
      document_id: documentId,
      chart_type: options.chartType || 'process',
      max_steps: options.maxSteps || 15
    };

    return this.makeRequest('/api/flowchart/generate', {
      method: 'POST',
      body: JSON.stringify(payload)
    });
  }

  async getServiceHealth() {
    return this.makeRequest('/health');
  }

  async getServiceInfo() {
    return this.makeRequest('/info');
  }

  // Utility method to check if Python service is available
  async isServiceAvailable() {
    try {
      await this.getServiceHealth();
      return true;
    } catch {
      return false;
    }
  }
}

export default new AgentServiceClient();